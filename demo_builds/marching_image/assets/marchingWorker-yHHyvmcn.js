(function(){"use strict";const p=[[],[[0,0],[1,0],[0,1]],[[2,0],[1,0],[2,1]],[[0,0],[0,1],[2,0],[2,1]],[[2,2],[2,1],[1,2]],[[0,1],[1,0],[1,2],[2,1],[0,0],[2,2]],[[1,0],[1,2],[2,0],[2,2]],[[0,0],[0,1],[2,0],[2,2],[1,2]],[[0,2],[0,1],[1,2]],[[0,0],[1,0],[0,2],[1,2]],[[1,2],[0,1],[2,1],[1,0],[2,0],[0,2]],[[2,1],[0,0],[2,0],[0,2],[1,2]],[[0,2],[2,2],[2,1],[0,1]],[[0,2],[2,2],[0,0],[1,0],[2,1]],[[0,1],[0,2],[1,0],[2,0],[2,2]],[[0,0],[0,2],[2,0],[2,2]]],m=[[],[[0,1,2]],[[0,2,1]],[[0,3,1],[0,2,3]],[[0,2,1]],[[2,0,1],[1,3,2],[0,4,1],[3,5,2]],[[1,0,3],[3,0,2]],[[1,2,4],[1,0,2],[3,4,2]],[[0,1,2]],[[0,1,3],[0,3,2]],[[3,0,1],[2,0,3],[3,4,2],[0,5,1]],[[1,0,4],[0,1,2],[4,3,1]],[[0,2,1],[2,0,3]],[[0,4,1],[3,0,2],[4,0,3]],[[2,4,0],[4,2,3],[1,0,4]],[[1,0,3],[3,0,2]]],q=m.map(n=>n.map(e=>[e[0],e[2],e[1]])),M=[[],[[[0,1,0],[1,0,1],[1,0,0]],[[1,0,1],[0,1,0],[0,1,1]]],[[[1,0,0],[1,0,1],[2,1,0]],[[1,0,1],[2,1,1],[2,1,0]]],[[[0,1,0],[0,1,1],[2,1,1]],[[2,1,1],[2,1,0],[0,1,0]]],[[[2,1,1],[1,2,1],[2,1,0]],[[2,1,0],[1,2,1],[1,2,0]]],[[[1,0,0],[2,1,0],[1,0,1]],[[2,1,0],[2,1,1],[1,0,1]],[[0,1,1],[1,2,1],[0,1,0]],[[0,1,0],[1,2,1],[1,2,0]]],[[[1,0,0],[1,0,1],[1,2,0]],[[1,0,1],[1,2,1],[1,2,0]]],[[[0,1,1],[1,2,1],[0,1,0]],[[0,1,0],[1,2,1],[1,2,0]]],[[[0,1,1],[0,1,0],[1,2,1]],[[0,1,0],[1,2,0],[1,2,1]]],[[[1,0,0],[1,2,1],[1,0,1]],[[1,0,0],[1,2,0],[1,2,1]]],[[[2,1,1],[1,2,0],[1,2,1]],[[2,1,0],[1,2,0],[2,1,1]],[[1,0,0],[1,0,1],[0,1,0]],[[1,0,1],[0,1,1],[0,1,0]]],[[[2,1,1],[1,2,0],[1,2,1]],[[2,1,0],[1,2,0],[2,1,1]]],[[[2,1,0],[2,1,1],[0,1,1]],[[0,1,1],[0,1,0],[2,1,0]]],[[[1,0,0],[2,1,0],[1,0,1]],[[2,1,0],[2,1,1],[1,0,1]]],[[[1,0,0],[1,0,1],[0,1,0]],[[1,0,1],[0,1,1],[0,1,0]]],[]];class v{pos;constructor(e,t,s){this.pos=[e,t,s]}}class x{verts;constructor(e){this.verts=e}}function S(n,e){return[n[1]*e[2]-n[2]*e[1],n[2]*e[0]-n[0]*e[2],n[0]*e[1]-n[1]*e[0]]}function z(n){const e=Math.sqrt(n[0]**2+n[1]**2+n[2]**2);return e>0?[n[0]/e,n[1]/e,n[2]/e]:[0,0,0]}function L(n){const[e,t,s]=n[0].pos,[o,c,g]=n[1].pos,[a,r,l]=n[2].pos,d=[o-e,c-t,g-s],h=[a-e,r-t,l-s];return z(S(d,h))}function k(n,e="model"){let t=`solid ${e}
`;for(const s of n){if(s.verts.length!==3)throw new Error("STL requires triangular faces only.");const o=L(s.verts);t+=`  facet normal ${o[0]} ${o[1]} ${o[2]}
`,t+=`    outer loop
`;for(const c of s.verts)t+=`      vertex ${c.pos[0]} ${c.pos[1]} ${c.pos[2]}
`;t+=`    endloop
`,t+=`  endfacet
`}return t+=`endsolid ${e}
`,t}class I{verticies;faces;width=0;height=0;constructor(e,t,s){this.width=t,this.height=s,this.verticies=Array.from({length:s*2+1},()=>Array.from({length:t*2+1},()=>Array(2).fill(null))),this.vertsFromMatrix(e),this.faces=[]}vertsFromMatrix(e){let t=Math.sqrt(this.width*this.height)/5;for(let s=0;s<this.height-1;s++)for(let o=0;o<this.width-1;o++)this.addVertsFromSquare(e,o,s,t)}indexFromMatrix(e,t,s){let o=+(e[s][t]===1);return o+=+(e[s][t+1]===1)*2,o+=+(e[s+1][t+1]===1)*4,o+=+(e[s+1][t]===1)*8,o}addVertsFromSquare(e,t,s,o){const c=t*2,g=s*2,a=this.indexFromMatrix(e,t,s),r=p[a].length;for(let l=0;l<r;l++){const[d,h]=p[a][l],f=c+d,i=g+h;this.verticies[i][f][0]||(this.verticies[i][f][0]=new v(f-this.width+1,i-this.height+1,-o/2),this.verticies[i][f][1]=new v(f-this.width+1,i-this.height+1,o/2))}}marchSquare(e,t,s){let o=this.indexFromMatrix(e,t,s),c=m[o];for(let r=0;r<c.length;r++)try{let l=c[r],d=p[o],h=l.map(f=>{const[i,u]=d[f];return(i>2||u>2)&&console.log("dx: "+i+"dy: "+u),this.verticies[s*2+u][t*2+i][1]});this.faces.push(new x(h))}catch{console.log("topOffsets: "+c),console.log("index: "+o),console.log("i: "+r),console.log("offsets: "+c[r]),console.log("vl: "+p[o])}let g=q[o];for(let r=0;r<g.length;r++){let l=g[r],d=p[o],h=l.map(f=>{const[i,u]=d[f];return this.verticies[s*2+u][t*2+i][0]});this.faces.push(new x(h))}let a=M[o];for(let r=0;r<a.length;r++){const l=a[r];let d=[];for(let h=0;h<l.length;h++){const[f,i,u]=l[h],y=t*2+f,$=s*2+i,w=u,F=this.verticies[$]?.[y]?.[w];F||console.error(`Missing vertex! triIndex: ${r}, vertIndex: ${h}, index: ${o}, dx: ${f}, dy: ${i}, dz: ${u}, x: ${y}, y: ${$}, z: ${w}`),d.push(F)}this.faces.push(new x(d))}}marchingSquares(e){for(let t=0;t<e.length-1;t++)for(let s=0;s<e[0].length-1;s++)this.marchSquare(e,s,t)}export(){return this.faces.length==0?"":k(this.faces)}}onmessage=n=>{const{matrix:e,filename:t}=n.data;try{const s=new I(e,e[0].length,e.length);s.marchingSquares(e);const o=s.export();postMessage({stl:o,filename:t})}catch(s){postMessage({error:s.message,filename:t})}}})();
